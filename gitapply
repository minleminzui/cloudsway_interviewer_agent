diff --git a/backend/app/core/ws_tts_manager.py b/backend/app/core/ws_tts_manager.py
index 018c6bac22b1a529d11bd752548f9e2044037182..8e082e7a093c4e368808a3aeb836aedb683e249f 100644
--- a/backend/app/core/ws_tts_manager.py
+++ b/backend/app/core/ws_tts_manager.py
@@ -13,50 +13,51 @@ LOGGER = logging.getLogger(__name__)
 
 
 @dataclass
 class CancellationToken:
     _event: asyncio.Event = field(init=False, repr=False)
 
     def __post_init__(self) -> None:
         self._event = asyncio.Event()
 
     def cancel(self) -> None:
         self._event.set()
 
     def is_cancelled(self) -> bool:
         return self._event.is_set()
 
 
 class WsTtsManager:
     """Manage TTS websocket peers per session and allow stream cancellation."""
 
     def __init__(self) -> None:
         self._peers: Dict[str, Set[WebSocket]] = {}
         self._lock = asyncio.Lock()
         self._ready_events: Dict[str, asyncio.Event] = {}
         self._curr_task: Dict[str, asyncio.Task] = {}
         self._cancel_token: Dict[str, CancellationToken] = {}
+        self._pending_json: Dict[str, list[dict]] = {}
 
     async def register(self, sid: str, ws: WebSocket) -> None:
         LOGGER.info("Registering TTS peer handshake sid=%s", sid)
         await ws.accept()
         LOGGER.debug("Accepted TTS websocket sid=%s", sid)
         readiness_reset = False
         async with self._lock:
             peers = self._peers.setdefault(sid, set())
             peers.add(ws)
             peer_count = len(peers)
             ready_event = self._ready_events.get(sid)
             if ready_event is None:
                 ready_event = asyncio.Event()
                 self._ready_events[sid] = ready_event
                 readiness_reset = True
         LOGGER.info(
             "Registered TTS peer sid=%s peers=%d readiness_reset=%s",
             sid,
             peer_count,
             readiness_reset,
         )
         try:
             await ws.send_json({"type": "tts_ready", "mime": "audio/mpeg"})
         except BaseException as exc:
             readiness_reset = False
@@ -78,50 +79,51 @@ class WsTtsManager:
 
             await self._maybe_close_websocket(ws)
 
             LOGGER.warning(
                 (
                     "Failed to send readiness for sid=%s; dropping peer remaining=%d "
                     "readiness_reset=%s client_state=%s app_state=%s close_code=%s exc_type=%s"
                 ),
                 sid,
                 remaining,
                 readiness_reset,
                 getattr(ws, "client_state", None),
                 getattr(ws, "application_state", None),
                 getattr(ws, "close_code", None),
                 type(exc).__name__,
                 exc_info=True,
             )
             raise
         else:
             ready_event.set()
             LOGGER.info(
                 "Marked TTS session sid=%s ready; notifying waiters peers=%d",
                 sid,
                 peer_count,
             )
+            await self._flush_pending_json(sid)
 
     async def unregister(self, sid: str, ws: WebSocket) -> None:
         readiness_reset = False
         peer_count = 0
         async with self._lock:
             peers = self._peers.get(sid)
             if peers and ws in peers:
                 peers.remove(ws)
                 peer_count = len(peers)
                 if not peers:
                     self._peers.pop(sid, None)
                     # reset readiness so future waiters block until a new socket arrives
                     self._ready_events[sid] = asyncio.Event()
                     readiness_reset = True
             else:
                 peer_count = len(peers) if peers else 0
                 self._peers.pop(sid, None)
                 ready_event = self._ready_events.get(sid)
                 if ready_event is not None and ready_event.is_set():
                     self._ready_events.pop(sid, None)
                     readiness_reset = True
         LOGGER.info(
             "Unregistered TTS peer sid=%s peers=%d readiness_reset=%s",
             sid,
             peer_count,
@@ -137,61 +139,77 @@ class WsTtsManager:
                 self._ready_events[sid] = event
                 created = True
             already_ready = event.is_set()
         LOGGER.info(
             "Waiting for TTS readiness sid=%s created=%s already_ready=%s",
             sid,
             created,
             already_ready,
         )
         await event.wait()
         LOGGER.info("TTS readiness satisfied sid=%s", sid)
 
     async def _broadcast_bytes(self, sid: str, payload: bytes) -> None:
         peers = list(self._peers.get(sid, ()))
         to_drop: list[WebSocket] = []
         for ws in peers:
             try:
                 await ws.send_bytes(payload)
             except Exception:
                 LOGGER.error("Dropping TTS peer sid=%s due to bytes send error", sid, exc_info=True)
                 to_drop.append(ws)
         for ws in to_drop:
             await self.unregister(sid, ws)
 
     async def _broadcast_json(self, sid: str, payload: dict) -> None:
-        peers = list(self._peers.get(sid, ()))
+        async with self._lock:
+            peers = list(self._peers.get(sid, ()))
+            if not peers:
+                queue = self._pending_json.setdefault(sid, [])
+                queue.append(payload)
+                LOGGER.debug(
+                    "Queued JSON payload for sid=%s while no peers connected: %s",
+                    sid,
+                    payload,
+                )
+                return
         to_drop: list[WebSocket] = []
         for ws in peers:
             try:
                 await ws.send_json(payload)
             except Exception:
                 LOGGER.error("Dropping TTS peer sid=%s due to json send error", sid, exc_info=True)
                 to_drop.append(ws)
         for ws in to_drop:
             await self.unregister(sid, ws)
 
+    async def _flush_pending_json(self, sid: str) -> None:
+        async with self._lock:
+            pending = self._pending_json.pop(sid, [])
+        for payload in pending:
+            await self._broadcast_json(sid, payload)
+
     async def _maybe_close_websocket(self, ws: WebSocket) -> None:
         close_callable = getattr(ws, "close", None)
         if not close_callable:
             return
         try:
             result = close_callable()  # type: ignore[operator]
             if inspect.isawaitable(result):
                 await result
         except Exception:
             LOGGER.debug("Suppressing websocket close error after failed register", exc_info=True)
 
     async def send_audio_chunk(self, sid: str, chunk: bytes) -> None:
         await self._broadcast_bytes(sid, chunk)
 
     async def send_tts_end(self, sid: str) -> None:
         await self._broadcast_json(sid, {"type": "tts_end"})
 
     async def send_tts_error(self, sid: str, message: str) -> None:
         await self._broadcast_json(sid, {"type": "tts_error", "message": message})
 
     async def send_tts_fallback(self, sid: str, text: str) -> None:
         await self._broadcast_json(sid, {"type": "tts_fallback", "text": text})
 
 
     def start_stream(self, sid: str, task: asyncio.Task) -> CancellationToken:
diff --git a/backend/tests/test_tts_client.py b/backend/tests/test_tts_client.py
index 83c8fda4441c17bea50455914870a9f92216d9fc..a207cf6c572f83a972af71864f57a35ad69a8888 100644
--- a/backend/tests/test_tts_client.py
+++ b/backend/tests/test_tts_client.py
@@ -1,34 +1,35 @@
 from __future__ import annotations
 
 import base64
 from typing import Iterable, List
 
 import pytest
 import asyncio
 from types import SimpleNamespace
 from app.core import tts_client
+from app.core.ws_tts_manager import WsTtsManager
 
 
 class DummyResponse:
     def __init__(self, *, content_type: str, body: bytes, status: int = 200) -> None:
         self.headers = {"Content-Type": content_type}
         self._body = body
         self.status = status
 
     async def read(self) -> bytes:
         return self._body
 
     async def __aenter__(self) -> "DummyResponse":
         return self
 
     async def __aexit__(self, exc_type, exc, tb) -> bool:
         return False
 
 
 class DummySession:
     def __init__(self, responses: Iterable[DummyResponse]) -> None:
         self._responses: List[DummyResponse] = list(responses)
 
     async def __aenter__(self) -> "DummySession":
         return self
 
@@ -176,26 +177,73 @@ async def test_stream_and_broadcast_times_out_waiting_for_ws(monkeypatch: pytest
         async def send_audio_chunk(self, sid: str, chunk: bytes) -> None:  # pragma: no cover - unused
             raise AssertionError("audio should not be streamed when websocket never becomes ready")
 
         def finish_stream(self, sid: str, task: asyncio.Task) -> None:
             recorded["finished"] = True
 
     dummy_manager = DummyManager()
     monkeypatch.setattr(tts_client, "ws_manager", dummy_manager)
 
     synth_called = False
 
     async def fail_synth(text: str) -> bytes:  # pragma: no cover - should not be called
         nonlocal synth_called
         synth_called = True
         return b""
 
     monkeypatch.setattr(tts_client, "synth_once", fail_synth)
 
     await tts_client.stream_and_broadcast("s-timeout", "超时测试")
 
     assert recorded["ready_calls"] == 1
     assert recorded["error"] == "语音合成连接超时，已使用浏览器朗读。"
     assert recorded["fallback"] == "超时测试"
     assert recorded["end"] is True
     assert recorded["finished"] is True
-    assert synth_called is False
\ No newline at end of file
+
+
+class DummyWebSocket:
+    def __init__(self) -> None:
+        self.accepted = False
+        self.sent_json: list[dict] = []
+
+    async def accept(self) -> None:
+        self.accepted = True
+
+    async def send_json(self, payload: dict) -> None:
+        self.sent_json.append(payload)
+
+
+@pytest.mark.asyncio
+async def test_timeout_then_late_websocket_receives_cached_payload(monkeypatch: pytest.MonkeyPatch) -> None:
+    manager = WsTtsManager()
+    monkeypatch.setattr(tts_client, "ws_manager", manager)
+    monkeypatch.setattr(tts_client, "WS_READY_TIMEOUT", 0.01)
+    monkeypatch.setattr(tts_client, "VOLC_TTS_URL", "https://example.test/tts")
+    monkeypatch.setattr(tts_client, "VOLC_TTS_KEY", "key")
+    monkeypatch.setattr(tts_client, "VOLC_TTS_RES", "resource")
+
+    synth_called = False
+
+    async def synth_stub(_: str) -> bytes:  # pragma: no cover - not expected to run
+        nonlocal synth_called
+        synth_called = True
+        return b""
+
+    monkeypatch.setattr(tts_client, "synth_once", synth_stub)
+
+    text = "晚到的客户端"
+    await tts_client.stream_and_broadcast("sid-late", text)
+
+    ws = DummyWebSocket()
+    await manager.register("sid-late", ws)
+
+    assert ws.accepted is True
+    assert ws.sent_json[0] == {"type": "tts_ready", "mime": "audio/mpeg"}
+    assert ws.sent_json[1] == {
+        "type": "tts_error",
+        "message": "语音合成连接超时，已使用浏览器朗读。",
+    }
+    assert ws.sent_json[2] == {"type": "tts_fallback", "text": text}
+    assert ws.sent_json[3] == {"type": "tts_end"}
+    assert "sid-late" not in manager._pending_json
+    assert synth_called is False
